满足题意的区间右边不能出现比区间最大值更小的值， 比如 [2,1,0],  假如用[2]作为一个单独区间，后面出现了1比区间最大值2更小，这显然就不可能还原成正确的升序排序。  

所以区间最大值和其右边数组的比较，可以作为分区判断的参考。
同理，当前区间的最小值也不应小于左边区间的最大值。

下一步要解决的问题是，从左往右遍历，假如左边已经有了多个分区，当碰到一个值比左边某些分区最大值更小时，如何重新分区。 

很显然，左边最大值比这个当前值大的分区都应该合并成一个区，出现在包含当前值的分区左边不能有最大值比当前值更大的分区。

对于这个解决方式，有几种数据结构可以处理，我认为性能最佳的解决方案是， 只需要用一个数组记录每个分区的最大值， 然后用一个指针p， 来调整当前分区的最大值应记录在数组的什么位置，对目标遍历一次后， 指针p的值就是答案。

另外由于arr[i] > 0， 为了减少循环里不必要的判断，记录分区最大值的数组第一位可以初始化为0。 代表最左边默认有一个最大值为0的假设分区。

代码里cur记录遍历时当前分区最大值。
