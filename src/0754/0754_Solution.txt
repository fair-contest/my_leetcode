解题思路
1. 因为左右移动不受限制，所以target为负数时，其最小移动实现步数和target为正时互为以0为中点的镜像，结果是一样的，为了方便计算，可以先把target转为正数。

2. 由于每次移动范围都比之前大1，设累加值为n, 假设从1加到n的和sum刚刚好大于或等于target，设s = sum - target，这个s也小于n的情况就是刚刚好大于或等于target，要使移动后刚好为target, 就要有操作能抵消掉这个s。 这个抵消操作的最小值加上n-1就是答案。

3. 假如有某步向左移动，其要回到0时，其对累加和产生的负作用必然是这一步的两倍，比如第一步左移变为-1， 还要多加回1才回到0， 所以当s为偶数时，必可对应某步向左移，可以一步抵消s，这个左移的步数是|s/2|, 以13举例，1+2+3+4+5 = 15刚好大于13， 13-15为-2， |-2/2| = 1, 说明只要第一步左移即可, 2+3+4+5 = 13。 反过来同理，当s为奇数时，这个抵消s的操作就必然不能1步完成。

4. 连续的两个数只要向相反移动，就能产生1或-1，所以s若是奇数，搭配上1或-1就是偶数了。 以14举例, 15刚好大于14, 14-15为-1，连续的n+1和n+2即6和7就可以产生一个-1，即只要把7左移，1到6的累加和减7就是14，同理如果target是12，12-15为-3， 同前理，7左移后和6产生1个-1，剩下的差距2就是偶数了，2/2 =1, 就是说1也应该左移，1和7左移，对应右移的23456，即2+3+4+5+6-1-7结果正好就是12。 因为要抵消的s不大于n，所以s为偶数时，它除以2的值也必然在1到n的数字中，从上面可推导证明最优操作不会高于n+2次。 且此时移动方案为：
n+2左移，s减1后除以2对应的那个数也左移，即可等于target。

5. 当n为偶数时，比如target为7时，n是4，s是7-10=-3, 虽然这时用上面第4点的方法，很容易得出，利用5和6可产生一个-1，然后2/2=1, 即把1也左移，即2+3+4+5-6-1=7， 但这种时候，6次不是最优解。 因为有 2+4+5-1-3 = 7，只需要5次。 这是因为n是偶数时, 需要的-1可以直接从1的左移获得，((n+1)+s)/2-1 后就能得到另一个应该左移的数字。
这里n是4，s=3，套进这个式子里就是(4+1+3)/2-1 = 3， 应把1和3左移。 这个式子不能用于n为奇数的原因也很明显，因为n+1+s为奇数的话，不能整除2，因为已经有s是奇数的前提，所以n只能是偶数时才能应用这个式子。

详细移动方案推导完毕。

由于1+2+3+4+...+n= n*(n+1)/2，即前面推导过程中的条件等同于n*(n+1)/2 刚好大于或等于target
换算一下可得 2 * target <= n * n + n， 由于也有target >= n*(n-1)/2 ，即2 * target >= n * n - n
所以可用 2 * target 的开方然后四舍五入取整来求n值。

这个算法时间复杂度取决于开方的时间复杂度。
空间复杂度：O(1)
