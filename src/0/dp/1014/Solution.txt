第一种解法思路：动态规划

由题意 i < j， 对于任意一个位置j， 由于 j 值和 values[j] 对于 j 位置本身都是相对不变的，所以其与 j 左边任意一个 i 的最高分组合只取决于 value[i] + i 的最大值。

所以可以拿 j 作为参考从左向右遍历数组values, 并在遍历时更新 j 左边的value[i]+i的最大值和 value[j]-j 的和，即可求得一对观光景点的最高分。

由于每个位置 j 和 j-1 的主要差异就是 j-1 位置会变成对于 j 位置的新 i 值，因此只需要比对 value[j-1] + (j-1) 和之前的 value[i]+i 的最大值，并保留两者中最大的值。

写成状态转移方程即相当于
dp[j] = max(dp[j-1], values[j-1] + j - 1)

不过，这题不需要整个动态规划查找表，实际上只需要两个变量存放局部最大值( j 左边 value[i]+i 的最大值)，和全局最大值（即要返回的答案）。


第二种解法思路：换位迭代
从左向右遍历时，一个很容易想到的思路就是遍历时左边数字中的最大值与当前值相加，再不断更新相加后的最大值来获得答案，但这个思路不能直接应用的原因就是还要考虑两个数字下标的距离，那么我们有没有办法把下标距离这个干扰项去掉呢？答案是有的，我们只要使两个要相加的数字距离固定为1，即始终相邻，就可以不考虑下标距离的不确定性。

那么怎么实现呢，从左向右遍历时，假设遍历到一个最大值， 下一步就可以假设这个最大值一直向右进行换位，使其一直与当前遍历值相邻。 举个例子来说：

比如数组 [4, 1, 1, 5],

遍历到下标1时，左边数中最大值为4，
遍历到下标2时，将这个最大值向右移一位，变成[1, 4, 1, 5]，它就与当前值相邻了。
遍历到下标3时，继续右移，变成[1, 1, 4, 5]。

实际上因为每次变换位置时，都是下标索引+1，所以只要每次把左边数中的最大值减1，并不需要真的进行数字移动的操作，就能在结果上达到同样的效果。

刚才遍历到下标3时，因为假设移动了2步，只需要4-2 = 2， 然后用这个2去和当前值5相加即可，一样可求出答案等于 2 + 5 - 1 = 6 （因为假设两数固定相邻1，所以最后还要再减个1）

时间复杂度：O(n)
空间复杂度：O(1)

虽然两个解法都是O(n)时间复杂度，但第二种解法从代码角度看还是要比第一种解法省一点点计算。
因为两个相对下标距离的计算部分已经被简洁的转换为固定距离1的计算了。

虽然第二种解法也可以写成动态规划的形式，但从换位迭代角度会更容易理解这个解法。

