解题思路
先对cuboids每个元素升序排列，然后使cuboids按立方体最短边的升序排列，这样后面计算时可以不考虑最短边。

注意：排序条件要设置当最短边一样时，要按第二短的边升序排，第二短边一样的情况下，按最长边升序排。

这样设置条件是后面的动态规划方法无后效性的关键。

然后因为不用考虑最短边，可以直接利用原本最短边的位置把cuboids变成动态规划查找表。

dp = cuboids

可以将 dp[i] 位置理解为一组已经堆叠好的立方体， dp[i][1] 和 dp[i][2] 记录的是这组立方体最下面的那个立方体的属性。

dp[i][0] 这个位置可以记录这组立方体的整体高度。

由于已排好序，所以能放在 dp[i][1] 和 dp[i][2] 为边属性上的立方体上的几乎所有立方体都在 dp[i] 位置的左边。

唯一例外是长宽高属性完全一样的立方体，有可能在右边，但这种情况下必然能互相叠加，所以不影响结果。

如前面排序不当，就可能漏掉一些本应叠加而因为次序不对，无法叠加漏计算的立方体。

假设 dp[i] 左边有个 dp[j], 满足dp[j][1] <= dp[i][1], 且dp[j][2] <= dp[j][2], 那么 dp[j] 位置代表的一组立方体即可叠加于 dp[i] 属性记录的最下面那个立方体上。

所以可先遍历一次dp查找表，获得i位置左边符合以上条件的所有 dp[j][0] ，即之前记录的每种组合的整体高度，并取其中最大值，加上 dp[i][2] 后记录在 dp[i][0] 上。

dp[i][0] 位置现在记录下的就是i位置属性的立方体能和它左边那些立方体组合出的最大高度。

最后对整个dp数组每个 dp[i][0] 位置进行遍历，求最大的 dp[i][0] 值就是答案。

（PS: 我以上赋予动态规划的含义本身就是一个证明。 这组定义保证了必然最后的答案就是所求的最大高度。）

时间复杂度：O(n^2), 因为内循环次数相当于0.5 * n * (n - 1)次，去掉常数项，即为n^2级别。
空间复杂度：O(n)
