### 解题思路
如果n为10的m次方，digits的长度为k, 那么能组合成小于n的数字可以表示为[k的1次方, k的2次方...k的m次方]这个数组的总和。
以题目的示例1为例, digits = ["1","3","5","7"], n = 100。
digits长度为4，可以表示为[4的1次方, 4的2次方]，即[4, 16]的总和20，这个数组里的每一个元素其实都相当于digits和不同位数的笛卡尔积。
因为我的解法后续要用到这个列表，所以会预生成一个，代码里是plist。

然后，分两种情况循环处理n的每一数位。
第一种情况是，digits里小于当前数位的个数，还是取之前例子，n改为400，当前数位为4时，那么["1","3","5","7"]里小于4的只有2个，就是1和3。
这种情况下，100以上到400之间的部分，将是长度为2的数位与digits的笛卡尔积的倍数，如果我前面的plist是逆序生成，这个就是plist[0] x 2,
所以n为400时的答案就是100以下部分和100以上部分的和：20 + 16 x 2 = 52。 
同理n为800到999时，答案是20 + 16 x 4 = 84

第二种情况是，digits里小于等于当前数位的个数，这个是n最后一位如果需要处理，要用这个判断来处理，因为比如n = 3时， ["1","3","5","7"]里小于
3的只有1个，而小于等于3的有两个， 2个才是正确答案。

此外，当循环处理数位时，碰到第二种情况个数为0，也可中断循环， 不需要继续计算，因为比如n为73999, digits = ["4","5","6","7"]，
当判断到73999里那个3时，因为这个3小于digits里所有元素，意味着答案已经出来了，往后计算也不会碰到全部由digits组成的数字了，计算即可中止。

而且如果digits里小于等于当前数位的个数和小于当前数位的个数是一样的，也相当于答案已经出来了， 可中止计算。
例如前面提到的，digits=["1","3","5","7"]时，800到999的答案是一样的。因为800到999之间的数字，不可能完全由digits组成了。 
其实这里777到999的答案都一样是84，这个解法在800的第一个8时就可以判断出不需要计算后面的部分了。
